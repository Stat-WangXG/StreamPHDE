% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/Func_PH_Online_Hetero.R
\name{PH.Renew.Hetero.ALasso.Batch}
\alias{PH.Renew.Hetero.ALasso.Batch}
\title{Online estimation in Cox proportional hazards model with dynamic covariate effects}
\usage{
PH.Renew.Hetero.ALasso.Batch(
  yobs,
  delta,
  X,
  initial = TRUE,
  prev = NULL,
  boots = list(do = FALSE, nboot = 100, trace = TRUE),
  tunpara.num = 50,
  tunpara.min.ratio = 1e-04,
  tunpara = NULL,
  evatype = c("AIC", "BIC")[2],
  learnrate = c(0.4),
  maxit = 1000,
  eps = 1e-06,
  threshold = 5e-05,
  trace = TRUE
)
}
\arguments{
\item{yobs}{time to event of interest.}

\item{delta}{the censoring indicator, normally 1 = event of interest happens, and 0 = censoring.}

\item{X}{a matrix of covariates.}

\item{initial}{a logical value. The default specification is \code{TRUE}, indicating that the current data batch is the first batch and no historical summary statistics is available.}

\item{prev}{indicates the historical summary data. The default specification is \code{NULL} (with \code{initial=TRUE}). Otherwise, it is a list with the following five elements:
\code{bet} is the historical estimated result of regression coefficients;
\code{bet.batch} is the historical estimated result of regression coefficients using only the previous dataset;
\code{InfoM} is the historical estimated result of the information matrix;
\code{N} is the sample of historical raw data.}

\item{boots}{basic setup of the bootstrap procedure.}

\item{tunpara.num}{the number of tuning parameter values that will be fitted at.}

\item{tunpara.min.ratio}{Smallest value for tuning parameter, as a fraction of tunpara.max, the (data derived) entry value (i.e. the smallest value for which all coefficients are zero).}

\item{tunpara}{A user supplied \code{tunpara} sequence. Typical usage is to have the program compute its own \code{tunpara} sequence based on \code{tunpara.num} and \code{tunpara.min.ratio}. Supplying a value of \code{tunpara} overrides this.}

\item{evatype}{the information criterion that will be used in the selection of optimal tuning parameter.}

\item{learnrate}{the learning rate in solving the optimization problem.}

\item{maxit}{specifies the maximum iteration number. If the convergence criterion is not met, the iteration will be stopped after emmax iterations and the estimates will be based on the last maximum likelihood iteration. The default \code{maxit = 5e3}.}

\item{eps}{tolerance for convergence. The default is \code{eps = 1e-6}. Iteration stops once the relative change in deviance is less than \code{eps}.}

\item{threshold}{a threshold value. The deafult value is \code{1e-5}. If the absolute value of the each component of coefficients is smaller than \code{threshold}, it will be converted into zero.}

\item{trace}{a logical value. The default specification is \code{TRUE}, indicating that several useful information about the current process of fitting will be displayed.}
}
\value{
The fitted results are returned (a list). The estimates of regression coefficients is \code{resbet}.
}
\description{
Conduct Online estimation in Cox proportional hazards model with dynamic covariate effects.
}
\examples{
### ==== An example for fitting the online Cox proportional hazards model (Heterogeneity exist) ==== ###

## ---- basic setup of the simulated dataset ---- ##
pbet <- 3
B.oT <- 5
Nb.oT <- 400
bettau.jump <- matrix(
  c(c( 1,-2, 0),  # bet0
    c(-1, 0, 2),  # bet1
    c( 1, 0, 0)), # bet2
  ncol=pbet)
Tnum <- nrow(bettau.jump)
bettau.all  <- matrix(0,nrow=B.oT*Tnum,ncol=pbet)
bettau.all[(0:(Tnum-1))*B.oT+1,]  <- bettau.jump
bet.all <- apply(bettau.all,2,cumsum)

## ---- fit the  Cox proportional hazards model in an online manner ---- ##
# prepare basic elements
B  <- nrow(bet.all)
Nb <- Nb.oT
N <- B*Nb
Res.Online <- array(0,dim=c(B,pbet,2),
                    dimnames=list(paste("batch",1:B,sep=""),paste("bet",1:pbet,sep=""),c("EST","SE")))
Res.Online_Hetero <- list(
  res = array(0,dim=c(B,pbet,2),
              dimnames=list(paste("batch",1:B,sep=""),paste("bet",1:pbet,sep=""),c("EST","SE"))),
  restau = array(0,dim=c(B-1,pbet,2),
                 dimnames=list(paste("batch",2:B,sep=""),paste("taub",1:pbet,sep=""),c("EST","SE")))
)
# Online estimation procedures
for(b in 1:B){ # b <- 1
  cat("-------------------------\nCurrent batch number: ",b,"\n")

  ## Generate the current data batch
  sdata.batch  <- sdata.PH(N=Nb,bet=bet.all[b,])
  yobs  <- sdata.batch$sdata$yobs
  delta <- sdata.batch$sdata$delta
  X     <- as.matrix(sdata.batch$sdata$X)

  ### ____ Online PH (homogeneous) ____ ###
  ## preparation: the previous elements
  if(b==1){ prevb <- NULL }else{
    prevb <- c(
      fitb$fit
    )
  }
  ## updating
  fitb <- PH.Renew.Batch(
    yobs=yobs,delta=delta,X=X,
    initial=(b==1),prev=prevb)
  Res.Online[b,,1] <- fitb$res[,1]
  Res.Online[b,,2] <- fitb$res[,2]

  ### ____ Online PH (heterogeneous) ____ ###
  ## preparation: the previous elements
  if(b==1){ prevb.Hetero <- NULL }else{
    prevb.Hetero <- c(
      fitb.Hetero$fit,
      fit.boots=list(fitb.Hetero$fit.boots)
    )
  }
  ## updating
  fitb.Hetero <- PH.Renew.Hetero.ALasso.Batch(
    yobs=yobs,delta=delta,X=X,
    initial=(b==1),prev=prevb.Hetero,
    boots=list(do=TRUE,nboot=100,trace=TRUE))
  Res.Online_Hetero$res[b,,1] <- fitb.Hetero$resbet[,1] # Res.Online_Hetero$res[,,1]
  Res.Online_Hetero$res[b,,2] <- fitb.Hetero$resbet[,2]
  if(b>1){
    Res.Online_Hetero$restau[b-1,,1] <- fitb.Hetero$restau[,1] # Res.Online_Hetero$restau[,,1]
    Res.Online_Hetero$restau[b-1,,2] <- fitb.Hetero$restau[,2]
  }

}
# present the fitted results
print(Res.Online)
print(Res.Online_Hetero$res)
print(Res.Online_Hetero$restau)

}
